# 一、图论理论基础

这一篇我们正式开始图论！

## 图的基本概念

二维坐标中，两点可以连成线，多个点连成的线就构成了图。

当然图也可以就一个节点，甚至没有节点（空图）

### 图的种类

整体上一般分为 有向图 和 无向图。

有向图是指 图中边是有方向的：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240510195737.png（图像链接）

无向图是指 图中边没有方向：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240510195451.png（图像链接）

加权有向图，就是图中边是有权值的，例如：

加权无向图也是同理。

### 度

无向图中有几条边连接该节点，该节点就有几度。

例如，该无向图中，节点4的度为5，节点6的度为3。

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511115029.png（图像链接）

在有向图中，每个节点有出度和入度。

出度：从该节点出发的边的个数。

入度：指向该节点边的个数。

例如，该有向图中，节点3的入度为2，出度为1，节点1的入度为0，出度为2。

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511115235.png（图像链接）

## 连通性

在图中表示节点的连通情况，我们称之为连通性。

### 连通图

在无向图中，任何两个节点都是可以到达的，我们称之为连通图 ，如图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511102351.png（图像链接）

如果有节点不能到达其他节点，则为非连通图，如图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511102449.png（图像链接）

节点1 不能到达节点4。

### 强连通图

在有向图中，任何两个节点是可以相互到达的，我们称之为 强连通图。

这里有录友可能想，这和无向图中的连通图有什么区别，不是一样的吗？

我们来看这个有向图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511104531.png（图像链接）

这个图是强连通图吗？

初步一看，好像这节点都连着呢，但这不是强连通图，节点1 可以到节点5，但节点5 不能到 节点1 。

强连通图是在有向图中**任何两个节点是可以相互到达**

下面这个有向图才是强连通图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511113101.png（图像链接）

### 连通分量

在无向图中的极大连通子图称之为该图的一个连通分量。

只看概念大家可能不理解，我来画个图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511111559.png（图像链接）

该无向图中 节点1、节点2、节点5 构成的子图就是 该无向图中的一个连通分量，该子图所有节点都是相互可达到的。

同理，节点3、节点4、节点6 构成的子图 也是该无向图中的一个连通分量。

那么无向图中 节点3 、节点4 构成的子图 是该无向图的联通分量吗？

不是！

因为必须是极大联通子图才能是连通分量，所以 必须是节点3、节点4、节点6 构成的子图才是连通分量。

在图论中，连通分量是一个很重要的概念，例如岛屿问题（后面章节会有专门讲解）其实就是求连通分量。

### 强连通分量

在有向图中极大强连通子图称之为该图的强连通分量。

如图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511112951.png（图像链接）

节点1、节点2、节点3、节点4、节点5 构成的子图是强连通分量，因为这是强连通图，也是极大图。

节点6、节点7、节点8 构成的子图 不是强连通分量，因为这不是强连通图，节点8 不能达到节点6。

节点1、节点2、节点5 构成的子图 也不是 强连通分量，因为这不是极大图。

## 图的构造

我们如何用代码来表示一个图呢？

一般使用邻接表、邻接矩阵 或者用类来表示。

主要是 朴素存储、邻接表和邻接矩阵。

### 邻接矩阵

邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。

例如： grid[2][5] = 6，表示 节点 2 连接 节点5 为有向图，节点2 指向 节点5，边的权值为6。

如果想表示无向图，即：grid[2][5] = 6，grid[5][2] = 6，表示节点2 与 节点5 相互连通，权值为6。

如图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240222110025.png（图像链接）

在一个 n （节点数）为8 的图中，就需要申请 8 \* 8 这么大的空间。

图中有一条双向边，即：grid[2][5] = 6，grid[5][2] = 6

这种表达方式（邻接矩阵） 在 边少，节点多的情况下，会导致申请过大的二维数组，造成空间浪费。

而且在寻找节点连接情况的时候，需要遍历整个矩阵，即 n \* n 的时间复杂度，同样造成时间浪费。

邻接矩阵的优点：

* 表达方式简单，易于理解
* 检查任意两个顶点间是否存在边的操作非常快
* 适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。

缺点：

* 遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n \* n矩阵，造成时间浪费

### 邻接表

邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。

邻接表的构造如图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240223103713.png（图像链接）

这里表达的图是：

* 节点1 指向 节点3 和 节点5
* 节点2 指向 节点4、节点3、节点5
* 节点3 指向 节点4
* 节点4指向节点1

有多少边 邻接表才会申请多少个对应的链表节点。

从图中可以直观看出 使用 数组 + 链表 来表达 边的连接情况 。

邻接表的优点：

* 对于稀疏图的存储，只需要存储边，空间利用率高
* 遍历节点连接情况相对容易

缺点：

* 检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。
* 实现相对复杂，不易理解

**以上大家可能理解比较模糊，没关系**，因为大家还没做过图论的题目，对于图的表达没有概念。

这里我先不给出具体的实现代码，大家先有个初步印象，在后面算法题实战中，我还会讲到具体代码实现，等带大家做算法题，写了代码之后，自然就理解了。

## 图的遍历方式

图的遍历方式基本是两大类：

* 深度优先搜索（dfs）
* 广度优先搜索（bfs）

在讲解二叉树章节的时候，其实就已经讲过这两种遍历方式。

二叉树的递归遍历，是dfs 在二叉树上的遍历方式。

二叉树的层序遍历，是bfs 在二叉树上的遍历方式。

dfs 和 bfs 一种搜索算法，可以在不同的数据结构上进行搜索，在二叉树章节里是在二叉树这样的数据结构上搜索。

而在图论章节，则是在图（邻接表或邻接矩阵）上进行搜索。

## 总结

以上知识点 大家先有个印象，上面提到的每个知识点，其实都需要大篇幅才能讲明白的。

我这里先给大家做一个概括，后面章节会针对每个知识点都会有对应的算法题和针对性的讲解，大家再去深入学习。

# 二、深度优先搜索理论基础

录友们期待图论内容已久了，为什么鸽了这么久，主要是最近半年开始更新[代码随想录算法公开课 **(opens new window)**](https://www.bilibili.com/video/BV1fA4y1o715/)，是开源在B站的算法视频，已经帮助非常多基础不好的录友学习算法。

录视频其实是非常累的，也要花很多时间，所以图论这边就没抽出时间来。

后面计划先给大家讲图论里大家特别需要的深搜和广搜。

以下，开始讲解深度优先搜索理论基础：

## dfs 与 bfs 区别

提到深度优先搜索（dfs），就不得不说和广度优先搜索（bfs）有什么区别

先来了解dfs的过程，很多录友可能对dfs（深度优先搜索），bfs（广度优先搜索）分不清。

先给大家说一下两者大概的区别：

* dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。
* bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。

当然以上讲的是，大体可以这么理解，接下来 我们详细讲解dfs，（bfs在用单独一篇文章详细讲解）

## dfs 搜索过程

上面说道dfs是可一个方向搜，不到黄河不回头。 那么我们来举一个例子。

如图一，是一个无向图，我们要搜索从节点1到节点6的所有路径。

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707093643.png（图像链接）

那么dfs搜索的第一条路径是这样的： （假设第一次延默认方向，就找到了节点6），图二

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707093807.png（图像链接）

此时我们找到了节点6，（遇到黄河了，是不是应该回头了），那么应该再去搜索其他方向了。 如图三：

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707094011.png（图像链接）

路径2撤销了，改变了方向，走路径3（红色线）， 接着也找到终点6。 那么撤销路径2，改为路径3，在dfs中其实就是回溯的过程（这一点很重要，很多录友不理解dfs代码中回溯是用来干什么的）

又找到了一条从节点1到节点6的路径，又到黄河了，此时再回头，下图图四中，路径4撤销（回溯的过程），改为路径5。

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707094322.png（图像链接）

又找到了一条从节点1到节点6的路径，又到黄河了，此时再回头，下图图五，路径6撤销（回溯的过程），改为路径7，路径8 和 路径7，路径9， 结果发现死路一条，都走到了自己走过的节点。

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707094813.png（图像链接）

那么节点2所连接路径和节点3所链接的路径 都走过了，撤销路径只能向上回退，去选择撤销当初节点4的选择，也就是撤销路径5，改为路径10 。 如图图六：

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707095232.png（图像链接）

上图演示中，其实我并没有把 所有的 从节点1 到节点6的dfs（深度优先搜索）的过程都画出来，那样太冗余了，但 已经把dfs 关键的地方都涉及到了，关键就两点：

* 搜索方向，是认准一个方向搜，直到碰壁之后再换方向
* 换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。

## 代码框架

正是因为dfs搜索可一个方向，并需要回溯，所以用递归的方式来实现是最方便的。

很多录友对回溯很陌生，建议先看看代码随想录，[回溯算法章节](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)。

有递归的地方就有回溯，那么回溯在哪里呢？

就递归函数的下面，例如如下代码：

```cpp
void dfs(参数) {
    处理节点
    dfs(图，选择的节点); // 递归
    回溯，撤销处理结果
}
```

可以看到回溯操作就在递归函数的下面，递归和回溯是相辅相成的。

在讲解[二叉树章节](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)的时候，二叉树的递归法其实就是dfs，而二叉树的迭代法，就是bfs（广度优先搜索）

所以**dfs，bfs其实是基础搜索算法，也广泛应用与其他数据结构与算法中**。

我们再回顾一下[回溯法](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)的代码框架：

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```

回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：

```cpp
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}

```

可以发现dfs的代码框架和回溯算法的代码框架是差不多的。

下面我在用 深搜三部曲，来解读 dfs的代码框架。

## 深搜三部曲

在 [二叉树递归讲解](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html)中，给出了递归三部曲。

[回溯算法](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)讲解中，给出了 回溯三部曲。

其实深搜也是一样的，深搜三部曲如下：

1. 确认递归函数，参数

```cpp
void dfs(参数)
```

通常我们递归的时候，我们递归搜索需要了解哪些参数，其实也可以在写递归函数的时候，发现需要什么参数，再去补充就可以。

一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。

例如这样：

```cpp
vector<vector<int>> result; // 保存符合条件的所有路径
vector<int> path; // 起点到终点的路径
void dfs (图，目前搜索的节点)  
```

但这种写法看个人习惯，不强求。

2. 确认终止条件

终止条件很重要，很多同学写dfs的时候，之所以容易死循环，栈溢出等等这些问题，都是因为终止条件没有想清楚。

```cpp
if (终止条件) {
    存放结果;
    return;
}
```

终止添加不仅是结束本层递归，同时也是我们收获结果的时候。

另外，其实很多dfs写法，没有写终止条件，其实终止条件写在了， 下面dfs递归的逻辑里了，也就是不符合条件，直接不会向下递归。这里如果大家不理解的话，没关系，后面会有具体题目来讲解。

3. 处理目前搜索节点出发的路径

一般这里就是一个for循环的操作，去遍历 目前搜索节点 所能到的所有节点。

```cpp
for (选择：本节点所连接的其他节点) {
    处理节点;
    dfs(图，选择的节点); // 递归
    回溯，撤销处理结果
}
```

不少录友疑惑的地方，都是 dfs代码框架中for循环里分明已经处理节点了，那么 dfs函数下面 为什么还要撤销的呢。

如图七所示， 路径2 已经走到了 目的地节点6，那么 路径2 是如何撤销，然后改为 路径3呢？ 其实这就是 回溯的过程，撤销路径2，走换下一个方向。

https://code-thinking-1253855093.file.myqcloud.com/pics/20220708093544.png（图像链接）

## 总结

我们讲解了，dfs 和 bfs的大体区别（bfs详细过程下篇来讲），dfs的搜索过程以及代码框架。

最后还有 深搜三部曲来解读这份代码框架。

以上如果大家都能理解了，其实搜索的代码就很好写，具体题目套用具体场景就可以了。

后面我也会给大家安排具体练习的题目，依旧是代码随想录的风格，循序渐进由浅入深！

图论是非常庞大的知识体系，上面的内容还不足以概括图论内容，仅仅是理论基础而已。

在图论章节我会带大家深入讲解 深度优先搜索（DFS）、广度优先搜索（BFS）、并查集、拓扑排序、最小生成树系列、最短路算法系列等等。

敬请期待！
