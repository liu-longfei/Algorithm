# 一、图论理论基础

这一篇我们正式开始图论！

## 图的基本概念

二维坐标中，两点可以连成线，多个点连成的线就构成了图。

当然图也可以就一个节点，甚至没有节点（空图）

### 图的种类

整体上一般分为 有向图 和 无向图。

有向图是指 图中边是有方向的：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240510195737.png（图像链接）

无向图是指 图中边没有方向：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240510195451.png（图像链接）

加权有向图，就是图中边是有权值的，例如：

加权无向图也是同理。

### 度

无向图中有几条边连接该节点，该节点就有几度。

例如，该无向图中，节点4的度为5，节点6的度为3。

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511115029.png（图像链接）

在有向图中，每个节点有出度和入度。

出度：从该节点出发的边的个数。

入度：指向该节点边的个数。

例如，该有向图中，节点3的入度为2，出度为1，节点1的入度为0，出度为2。

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511115235.png（图像链接）

## 连通性

在图中表示节点的连通情况，我们称之为连通性。

### 连通图

在无向图中，任何两个节点都是可以到达的，我们称之为连通图 ，如图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511102351.png（图像链接）

如果有节点不能到达其他节点，则为非连通图，如图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511102449.png（图像链接）

节点1 不能到达节点4。

### 强连通图

在有向图中，任何两个节点是可以相互到达的，我们称之为 强连通图。

这里有录友可能想，这和无向图中的连通图有什么区别，不是一样的吗？

我们来看这个有向图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511104531.png（图像链接）

这个图是强连通图吗？

初步一看，好像这节点都连着呢，但这不是强连通图，节点1 可以到节点5，但节点5 不能到 节点1 。

强连通图是在有向图中**任何两个节点是可以相互到达**

下面这个有向图才是强连通图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511113101.png（图像链接）

### 连通分量

在无向图中的极大连通子图称之为该图的一个连通分量。

只看概念大家可能不理解，我来画个图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511111559.png（图像链接）

该无向图中 节点1、节点2、节点5 构成的子图就是 该无向图中的一个连通分量，该子图所有节点都是相互可达到的。

同理，节点3、节点4、节点6 构成的子图 也是该无向图中的一个连通分量。

那么无向图中 节点3 、节点4 构成的子图 是该无向图的联通分量吗？

不是！

因为必须是极大联通子图才能是连通分量，所以 必须是节点3、节点4、节点6 构成的子图才是连通分量。

在图论中，连通分量是一个很重要的概念，例如岛屿问题（后面章节会有专门讲解）其实就是求连通分量。

### 强连通分量

在有向图中极大强连通子图称之为该图的强连通分量。

如图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240511112951.png（图像链接）

节点1、节点2、节点3、节点4、节点5 构成的子图是强连通分量，因为这是强连通图，也是极大图。

节点6、节点7、节点8 构成的子图 不是强连通分量，因为这不是强连通图，节点8 不能达到节点6。

节点1、节点2、节点5 构成的子图 也不是 强连通分量，因为这不是极大图。

## 图的构造

我们如何用代码来表示一个图呢？

一般使用邻接表、邻接矩阵 或者用类来表示。

主要是 朴素存储、邻接表和邻接矩阵。

### 邻接矩阵

邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。

例如： grid[2][5] = 6，表示 节点 2 连接 节点5 为有向图，节点2 指向 节点5，边的权值为6。

如果想表示无向图，即：grid[2][5] = 6，grid[5][2] = 6，表示节点2 与 节点5 相互连通，权值为6。

如图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240222110025.png（图像链接）

在一个 n （节点数）为8 的图中，就需要申请 8 \* 8 这么大的空间。

图中有一条双向边，即：grid[2][5] = 6，grid[5][2] = 6

这种表达方式（邻接矩阵） 在 边少，节点多的情况下，会导致申请过大的二维数组，造成空间浪费。

而且在寻找节点连接情况的时候，需要遍历整个矩阵，即 n \* n 的时间复杂度，同样造成时间浪费。

邻接矩阵的优点：

* 表达方式简单，易于理解
* 检查任意两个顶点间是否存在边的操作非常快
* 适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。

缺点：

* 遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n \* n矩阵，造成时间浪费

### 邻接表

邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。

邻接表的构造如图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240223103713.png（图像链接）

这里表达的图是：

* 节点1 指向 节点3 和 节点5
* 节点2 指向 节点4、节点3、节点5
* 节点3 指向 节点4
* 节点4指向节点1

有多少边 邻接表才会申请多少个对应的链表节点。

从图中可以直观看出 使用 数组 + 链表 来表达 边的连接情况 。

邻接表的优点：

* 对于稀疏图的存储，只需要存储边，空间利用率高
* 遍历节点连接情况相对容易

缺点：

* 检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。
* 实现相对复杂，不易理解

**以上大家可能理解比较模糊，没关系**，因为大家还没做过图论的题目，对于图的表达没有概念。

这里我先不给出具体的实现代码，大家先有个初步印象，在后面算法题实战中，我还会讲到具体代码实现，等带大家做算法题，写了代码之后，自然就理解了。

## 图的遍历方式

图的遍历方式基本是两大类：

* 深度优先搜索（dfs）
* 广度优先搜索（bfs）

在讲解二叉树章节的时候，其实就已经讲过这两种遍历方式。

二叉树的递归遍历，是dfs 在二叉树上的遍历方式。

二叉树的层序遍历，是bfs 在二叉树上的遍历方式。

dfs 和 bfs 一种搜索算法，可以在不同的数据结构上进行搜索，在二叉树章节里是在二叉树这样的数据结构上搜索。

而在图论章节，则是在图（邻接表或邻接矩阵）上进行搜索。

## 总结

以上知识点 大家先有个印象，上面提到的每个知识点，其实都需要大篇幅才能讲明白的。

我这里先给大家做一个概括，后面章节会针对每个知识点都会有对应的算法题和针对性的讲解，大家再去深入学习。

图论是非常庞大的知识体系，上面的内容还不足以概括图论内容，仅仅是理论基础而已。

在图论章节我会带大家深入讲解 深度优先搜索（DFS）、广度优先搜索（BFS）、并查集、拓扑排序、最小生成树系列、最短路算法系列等等。

敬请期待！


# 二、深度优先搜索理论基础

录友们期待图论内容已久了，为什么鸽了这么久，主要是最近半年开始更新[代码随想录算法公开课 **(opens new window)**](https://www.bilibili.com/video/BV1fA4y1o715/)，是开源在B站的算法视频，已经帮助非常多基础不好的录友学习算法。

录视频其实是非常累的，也要花很多时间，所以图论这边就没抽出时间来。

后面计划先给大家讲图论里大家特别需要的深搜和广搜。

以下，开始讲解深度优先搜索理论基础：

## dfs 与 bfs 区别

提到深度优先搜索（dfs），就不得不说和广度优先搜索（bfs）有什么区别

先来了解dfs的过程，很多录友可能对dfs（深度优先搜索），bfs（广度优先搜索）分不清。

先给大家说一下两者大概的区别：

* dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。
* bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。

当然以上讲的是，大体可以这么理解，接下来 我们详细讲解dfs，（bfs在用单独一篇文章详细讲解）

## dfs 搜索过程

上面说道dfs是可一个方向搜，不到黄河不回头。 那么我们来举一个例子。

如图一，是一个无向图，我们要搜索从节点1到节点6的所有路径。

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707093643.png（图像链接）

那么dfs搜索的第一条路径是这样的： （假设第一次延默认方向，就找到了节点6），图二

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707093807.png（图像链接）

此时我们找到了节点6，（遇到黄河了，是不是应该回头了），那么应该再去搜索其他方向了。 如图三：

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707094011.png（图像链接）

路径2撤销了，改变了方向，走路径3（红色线）， 接着也找到终点6。 那么撤销路径2，改为路径3，在dfs中其实就是回溯的过程（这一点很重要，很多录友不理解dfs代码中回溯是用来干什么的）

又找到了一条从节点1到节点6的路径，又到黄河了，此时再回头，下图图四中，路径4撤销（回溯的过程），改为路径5。

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707094322.png（图像链接）

又找到了一条从节点1到节点6的路径，又到黄河了，此时再回头，下图图五，路径6撤销（回溯的过程），改为路径7，路径8 和 路径7，路径9， 结果发现死路一条，都走到了自己走过的节点。

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707094813.png（图像链接）

那么节点2所连接路径和节点3所链接的路径 都走过了，撤销路径只能向上回退，去选择撤销当初节点4的选择，也就是撤销路径5，改为路径10 。 如图图六：

https://code-thinking-1253855093.file.myqcloud.com/pics/20220707095232.png（图像链接）

上图演示中，其实我并没有把 所有的 从节点1 到节点6的dfs（深度优先搜索）的过程都画出来，那样太冗余了，但 已经把dfs 关键的地方都涉及到了，关键就两点：

* 搜索方向，是认准一个方向搜，直到碰壁之后再换方向
* 换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。

## 代码框架

正是因为dfs搜索可一个方向，并需要回溯，所以用递归的方式来实现是最方便的。

很多录友对回溯很陌生，建议先看看代码随想录，[回溯算法章节](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)。

有递归的地方就有回溯，那么回溯在哪里呢？

就递归函数的下面，例如如下代码：

```cpp
void dfs(参数) {
    处理节点
    dfs(图，选择的节点); // 递归
    回溯，撤销处理结果
}
```

可以看到回溯操作就在递归函数的下面，递归和回溯是相辅相成的。

在讲解[二叉树章节](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)的时候，二叉树的递归法其实就是dfs，而二叉树的迭代法，就是bfs（广度优先搜索）

所以**dfs，bfs其实是基础搜索算法，也广泛应用与其他数据结构与算法中**。

我们再回顾一下[回溯法](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)的代码框架：

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```

回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：

```cpp
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}

```

可以发现dfs的代码框架和回溯算法的代码框架是差不多的。

下面我在用 深搜三部曲，来解读 dfs的代码框架。

## 深搜三部曲

在 [二叉树递归讲解](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html)中，给出了递归三部曲。

[回溯算法](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)讲解中，给出了 回溯三部曲。

其实深搜也是一样的，深搜三部曲如下：

1. 确认递归函数，参数

```cpp
void dfs(参数)
```

通常我们递归的时候，我们递归搜索需要了解哪些参数，其实也可以在写递归函数的时候，发现需要什么参数，再去补充就可以。

一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。

例如这样：

```cpp
vector<vector<int>> result; // 保存符合条件的所有路径
vector<int> path; // 起点到终点的路径
void dfs (图，目前搜索的节点)  
```

但这种写法看个人习惯，不强求。

2. 确认终止条件

终止条件很重要，很多同学写dfs的时候，之所以容易死循环，栈溢出等等这些问题，都是因为终止条件没有想清楚。

```cpp
if (终止条件) {
    存放结果;
    return;
}
```

终止添加不仅是结束本层递归，同时也是我们收获结果的时候。

另外，其实很多dfs写法，没有写终止条件，其实终止条件写在了， 下面dfs递归的逻辑里了，也就是不符合条件，直接不会向下递归。这里如果大家不理解的话，没关系，后面会有具体题目来讲解。

3. 处理目前搜索节点出发的路径

一般这里就是一个for循环的操作，去遍历 目前搜索节点 所能到的所有节点。

```cpp
for (选择：本节点所连接的其他节点) {
    处理节点;
    dfs(图，选择的节点); // 递归
    回溯，撤销处理结果
}
```

不少录友疑惑的地方，都是 dfs代码框架中for循环里分明已经处理节点了，那么 dfs函数下面 为什么还要撤销的呢。

如图七所示， 路径2 已经走到了 目的地节点6，那么 路径2 是如何撤销，然后改为 路径3呢？ 其实这就是 回溯的过程，撤销路径2，走换下一个方向。

https://code-thinking-1253855093.file.myqcloud.com/pics/20220708093544.png（图像链接）

## 总结

我们讲解了，dfs 和 bfs的大体区别（bfs详细过程下篇来讲），dfs的搜索过程以及代码框架。

最后还有 深搜三部曲来解读这份代码框架。

以上如果大家都能理解了，其实搜索的代码就很好写，具体题目套用具体场景就可以了。

后面我也会给大家安排具体练习的题目，依旧是代码随想录的风格，循序渐进由浅入深！


# 三、98. 所有可达路径

[卡码网题目链接（ACM模式）(opens new window)](https://kamacoder.com/problempage.php?pid=1170)

【题目描述】

给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从节点 1 到节点 n 的路径。每条路径应以节点编号的列表形式表示。

【输入描述】

第一行包含两个整数 N，M，表示图中拥有 N 个节点，M 条边

后续 M 行，每行包含两个整数 s 和 t，表示图中的 s 节点与 t 节点中有一条路径

【输出描述】

输出所有的可达路径，路径中所有节点的后面跟一个空格，每条路径独占一行，存在多条路径，路径输出的顺序可任意。

如果不存在任何一条路径，则输出 -1。

注意输出的序列中，最后一个节点后面没有空格！ 例如正确的答案是 `1 3 5`,而不是 `1 3 5`， 5后面没有空格！

【输入示例】

```text
5 5
1 3
3 5
1 2
2 4
4 5
```

【输出示例】

```text
1 3 5
1 2 4 5  
```

提示信息

https://code-thinking-1253855093.file.myqcloud.com/pics/20240514103953.png（图像链接）

用例解释：

有五个节点，其中的从 1 到达 5 的路径有两个，分别是 1 -> 3 -> 5 和 1 -> 2 -> 4 -> 5。

因为拥有多条路径，所以输出结果为：

```text
1 3 5
1 2 4 5
```

或

```text
1 2 4 5
1 3 5
```

都算正确。

数据范围：

* 图中不存在自环
* 图中不存在平行边
* 1 <= N <= 100
* 1 <= M <= 500

## 插曲

本题和力扣 [797.所有可能的路径 **(opens new window)**](https://leetcode.cn/problems/all-paths-from-source-to-target/description/)是一样的，录友了解深度优先搜索之后，这道题目就是模板题，是送分题。

力扣是核心代码模式，把图的存储方式给大家定义好了，只需要写出深搜的核心代码就可以。

如果笔试的时候出一道原题 （笔试都是ACM模式，部分面试也是ACM模式），不少熟练刷力扣的录友都难住了，因为不知道图应该怎么存，也不知道自己存的图如何去遍历。

所以这也是为什么我要让大家练习 ACM模式

---

这道题目是深度优先搜索，比较好的入门题。

如果对深度优先搜索还不够了解，可以先看这里：[深度优先搜索的理论基础(opens new window)](https://programmercarl.com/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

我依然总结了深搜三部曲，如果按照代码随想录刷题的录友，应该刷过 二叉树的递归三部曲，回溯三部曲。

**大家可能有疑惑，深搜 和 二叉树和回溯算法 有什么区别呢**？ 什么时候用深搜 什么时候用回溯？

我在讲解[二叉树理论基础 **(opens new window)**](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)的时候，提到过，**二叉树的前中后序遍历其实就是深搜在二叉树这种数据结构上的应用**。

那么回溯算法呢，**其实 回溯算法就是 深搜，只不过针对某一搜索场景 我们给他一个更细分的定义，叫做回溯算法**。

那有的录友可能说：那我以后称回溯算法为深搜，是不是没毛病？

理论上来说，没毛病，但 就像是 二叉树 你不叫它二叉树，叫它数据结构，有问题不？ 也没问题对吧。

建议是 有细分的场景，还是称其细分场景的名称。 所以回溯算法可以独立出来，但回溯确实就是深搜。

## 图的存储

在[图论理论基础篇](https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html) 中我们讲到了 两种 图的存储方式：邻接表 和 邻接矩阵。

本题我们将带大家分别实现这两个图的存储方式。

### 邻接矩阵

邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。

本题我们会有n 个节点，因为节点标号是从1开始的，为了节点标号和下标对齐，我们申请 n + 1 \* n + 1 这么大的二维数组。

```cpp
vector<vector<int>> graph(n + 1, vector<int>(n + 1, 0));
```

输入m个边，构造方式如下：

```cpp
while (m--) {
    cin >> s >> t;
    // 使用邻接矩阵 ，1 表示 节点s 指向 节点t
    graph[s][t] = 1;
}
```

### 邻接表

邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。

邻接表的构造相对邻接矩阵难理解一些。

我在 [图论理论基础篇](https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html) 举了一个例子：

https://code-thinking-1253855093.file.myqcloud.com/pics/20240223103713.png（图像链接）

这里表达的图是：

* 节点1 指向 节点3 和 节点5
* 节点2 指向 节点4、节点3、节点5
* 节点3 指向 节点4
* 节点4指向节点1

我们需要构造一个数组，数组里的元素是一个链表。

C++写法：

```cpp
// 节点编号从1到n，所以申请 n+1 这么大的数组
vector<list<int>> graph(n + 1); // 邻接表，list为C++里的链表
```

输入m个边，构造方式如下：

```cpp
while (m--) {
    cin >> s >> t;
    // 使用邻接表 ，表示 s -> t 是相连的
    graph[s].push_back(t);
}
```

本题我们使用邻接表 或者 邻接矩阵都可以，因为后台数据并没有对图的大小以及稠密度做很大的区分。

以下我们使用邻接矩阵的方式来讲解，文末我也会给出 使用邻接表的整体代码。

**注意邻接表 和 邻接矩阵的写法都要掌握**！

## 深度优先搜索

本题是深度优先搜索的基础题目，关于深搜我在[图论深搜理论基础](https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html) 已经有详细的讲解，图文并茂。

关于本题我会直接使用深搜三部曲来分析，如果对深搜不够了解，建议先看 [图论深搜理论基础](https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)。

深搜三部曲来分析题目：

1. 确认递归函数，参数

首先我们dfs函数一定要存一个图，用来遍历的，需要存一个目前我们遍历的节点，定义为x。

还需要存一个n，表示终点，我们遍历的时候，用来判断当 x==n 时候 标明找到了终点。

（其实在递归函数的参数 不容易一开始就确定了，一般是在写函数体的时候发现缺什么，参加就补什么）

至于 单一路径 和 路径集合 可以放在全局变量，那么代码是这样的：

```cpp
vector<vector<int>> result; // 收集符合条件的路径
vector<int> path; // 0节点到终点的路径
// x：目前遍历的节点
// graph：存当前的图
// n：终点
void dfs (const vector<vector<int>>& graph, int x, int n) {
```

2. 确认终止条件

什么时候我们就找到一条路径了？

当目前遍历的节点 为 最后一个节点 n 的时候 就找到了一条 从出发点到终止点的路径。

```cpp
// 当前遍历的节点x 到达节点n 
if (x == n) { // 找到符合条件的一条路径
    result.push_back(path);
    return;
}
```

3. 处理目前搜索节点出发的路径

首先是要找到 x节点指向了哪些节点呢？ 遍历方式是这样的：

```text
for (int i = 1; i <= n; i++) { // 遍历节点x链接的所有节点
    if (graph[x][i] == 1) { // 找到 x指向的节点，就是节点i
    }
}
```

接下来就是将 选中的x所指向的节点，加入到 单一路径来。

```text
path.push_back(i); // 遍历到的节点加入到路径中来

```

进入下一层递归

```cpp
dfs(graph, i, n); // 进入下一层递归
```

最后就是回溯的过程，撤销本次添加节点的操作。

为什么要有回溯，我在[图论深搜理论基础](https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html) 也有详细的讲解。

该过程整体代码：

```cpp
for (int i = 1; i <= n; i++) { // 遍历节点x链接的所有节点
    if (graph[x][i] == 1) { // 找到 x链接的节点
        path.push_back(i); // 遍历到的节点加入到路径中来
        dfs(graph, i, n); // 进入下一层递归
        path.pop_back(); // 回溯，撤销本节点
    }
}
```

## 打印结果

ACM格式大家在输出结果的时候，要关注看看格式问题，特别是字符串，有的题目说的是每个元素后面都有空格，有的题目说的是 每个元素间有空格，最后一个元素没有空格。

有的题目呢，压根没说，那只能提交去试一试了。

很多录友在提交题目的时候发现结果一样，为什么提交就是不对呢。

例如示例输出是：

`1 3 5` 而不是 `1 3 5 `

即 5 的后面没有空格！

这是我们在输出的时候需要注意的点。

有录友可能会想，ACM格式就是麻烦，有空格没有空格有什么影响，结果对了不就行了？

ACM模式相对于核心代码模式（力扣） 更考验大家对代码的掌控能力。 例如工程代码里，输出输出都是要自己控制的。这也是为什么大公司笔试，都是ACM模式。

以上代码中，结果都存在了 result数组里（二维数组，每一行是一个结果），最后将其打印出来。（重点看注释）

```cpp
// 输出结果
if (result.size() == 0) cout << -1 << endl;
for (const vector<int> &pa : result) {
    for (int i = 0; i < pa.size() - 1; i++) { // 这里指打印到倒数第二个
        cout << pa[i] << " ";
    }
    cout << pa[pa.size() - 1]  << endl; // 这里再打印倒数第一个，控制最后一个元素后面没有空格
}
```

## 本题代码

### 邻接矩阵写法

```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<vector<int>> result; // 收集符合条件的路径
vector<int> path; // 1节点到终点的路径

void dfs (const vector<vector<int>>& graph, int x, int n) {
    // 当前遍历的节点x 到达节点n 
    if (x == n) { // 找到符合条件的一条路径
        result.push_back(path);
        return;
    }
    for (int i = 1; i <= n; i++) { // 遍历节点x链接的所有节点
        if (graph[x][i] == 1) { // 找到 x链接的节点
            path.push_back(i); // 遍历到的节点加入到路径中来
            dfs(graph, i, n); // 进入下一层递归
            path.pop_back(); // 回溯，撤销本节点
        }
    }
}

int main() {
    int n, m, s, t;
    cin >> n >> m;

    // 节点编号从1到n，所以申请 n+1 这么大的数组
    vector<vector<int>> graph(n + 1, vector<int>(n + 1, 0));

    while (m--) {
        cin >> s >> t;
        // 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的
        graph[s][t] = 1;
    }

    path.push_back(1); // 无论什么路径已经是从0节点出发
    dfs(graph, 1, n); // 开始遍历

    // 输出结果
    if (result.size() == 0) cout << -1 << endl;
    for (const vector<int> &pa : result) {
        for (int i = 0; i < pa.size() - 1; i++) {
            cout << pa[i] << " ";
        }
        cout << pa[pa.size() - 1]  << endl;
    }
}

```

### 邻接表写法

```cpp
#include <iostream>
#include <vector>
#include <list>
using namespace std;

vector<vector<int>> result; // 收集符合条件的路径
vector<int> path; // 1节点到终点的路径

void dfs (const vector<list<int>>& graph, int x, int n) {

    if (x == n) { // 找到符合条件的一条路径
        result.push_back(path);
        return;
    }
    for (int i : graph[x]) { // 找到 x指向的节点
        path.push_back(i); // 遍历到的节点加入到路径中来
        dfs(graph, i, n); // 进入下一层递归
        path.pop_back(); // 回溯，撤销本节点
    }
}

int main() {
    int n, m, s, t;
    cin >> n >> m;

    // 节点编号从1到n，所以申请 n+1 这么大的数组
    vector<list<int>> graph(n + 1); // 邻接表
    while (m--) {
        cin >> s >> t;
        // 使用邻接表 ，表示 s -> t 是相连的
        graph[s].push_back(t);

    }

    path.push_back(1); // 无论什么路径已经是从0节点出发
    dfs(graph, 1, n); // 开始遍历

    // 输出结果
    if (result.size() == 0) cout << -1 << endl;
    for (const vector<int> &pa : result) {
        for (int i = 0; i < pa.size() - 1; i++) {
            cout << pa[i] << " ";
        }
        cout << pa[pa.size() - 1]  << endl;
    }
}

```

## 总结

本题是一道简单的深搜题目，也可以说是模板题，和 [力扣797. 所有可能的路径 **(opens new window)**](https://leetcode.cn/problems/all-paths-from-source-to-target/description/)思路是一样一样的。

很多录友做力扣的时候，轻松就把代码写出来了， 但做面试笔试的时候，遇到这样的题就写不出来了。

在力扣上刷题不用考虑图的存储方式，也不用考虑输出的格式。

而这些都是 ACM 模式题目的知识点（图的存储方式）和细节（输出的格式）

所以我才会特别制作ACM题目，同样也重点去讲解图的存储和遍历方式，来帮大家去练习。

对于这种有向图路径问题，最合适使用深搜，当然本题也可以使用广搜，但广搜相对来说就麻烦了一些，需要记录一下路径。

而深搜和广搜都适合解决颜色类的问题，例如岛屿系列，其实都是 遍历+标记，所以使用哪种遍历都是可以的。

至于广搜理论基础，我们在下一篇在好好讲解，敬请期待！

## 其他语言版本

### Python


# 四、广度优先搜索理论基础

在[深度优先搜索](https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)的讲解中，我们就讲过深度优先搜索和广度优先搜索的区别。

广搜（bfs）是一圈一圈的搜索过程，和深搜（dfs）是一条路跑到黑然后再回溯。

## 广搜的使用场景

广搜的搜索方式就适合于解决两个点之间的最短路径问题。

因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。

当然，也有一些问题是广搜 和 深搜都可以解决的，例如岛屿问题，**这类问题的特征就是不涉及具体的遍历方式，只要能把相邻且相同属性的节点标记上就行**。 （我们会在具体题目讲解中详细来说）

## 广搜的过程

上面我们提过，BFS是一圈一圈的搜索过程，但具体是怎么一圈一圈来搜呢。

我们用一个方格地图，假如每次搜索的方向为 上下左右（不包含斜上方），那么给出一个start起始位置，那么BFS就是从四个方向走出第一步。

https://code-thinking-1253855093.file.myqcloud.com/pics/20220825104505.png（图像链接）

如果加上一个end终止位置，那么使用BFS的搜索过程如图所示：

https://code-thinking-1253855093.file.myqcloud.com/pics/20220825102653.png（图像链接）

我们从图中可以看出，从start起点开始，是一圈一圈，向外搜索，方格编号1为第一步遍历的节点，方格编号2为第二步遍历的节点，第四步的时候我们找到终止点end。

正是因为BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。

而且地图还可以有障碍，如图所示：

https://code-thinking-1253855093.file.myqcloud.com/pics/20220825103900.png（图像链接）

在第五步，第六步 我只把关键的节点染色了，其他方向周边没有去染色，大家只要关注关键地方染色的逻辑就可以。

从图中可以看出，如果添加了障碍，我们是第六步才能走到end终点。

只要BFS只要搜到终点一定是一条最短路径，大家可以参考上面的图，自己再去模拟一下。

## 代码框架

大家应该好奇，这一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历。

很多网上的资料都是直接说用队列来实现。

其实，我们仅仅需要一个容器，能保存我们要遍历过的元素就可以，**那么用队列，还是用栈，甚至用数组，都是可以的**。

**用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针**。

因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。

**如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历**。

因为栈是先进后出，加入元素和弹出元素的顺序改变了。

那么广搜需要注意 转圈搜索的顺序吗？ 不需要！

所以用队列，还是用栈都是可以的，但大家都习惯用队列了，**所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以**。

下面给出广搜代码模板，该模板针对的就是，上面的四方格的地图： （详细注释）

```cpp
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair<int ,int> cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }

}
```

## 总结

当然广搜还有很多细节需要注意的地方，后面我会针对广搜的题目还做针对性的讲解。

**因为在理论篇讲太多细节，可能会让刚学广搜的录友们越看越懵**，所以细节方面针对具体题目在做讲解。

本篇我们重点讲解了广搜的使用场景，广搜的过程以及广搜的代码框架。

其实在二叉树章节的[层序遍历 **(opens new window)**](https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)中，我们也讲过一次广搜，相当于是广搜在二叉树这种数据结构上的应用。

这次则从图论的角度上再详细讲解一次广度优先遍历。

相信看完本篇，大家会对广搜有一个基础性的认识，后面再来做对应的题目就会得心应手一些。


# 五、99. 岛屿数量

[卡码网题目链接（ACM模式）(opens new window)](https://kamacoder.com/problempage.php?pid=1171)

题目描述：

给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。

输入描述：

第一行包含两个整数 N, M，表示矩阵的行数和列数。

后续 N 行，每行包含 M 个数字，数字为 1 或者 0。

输出描述：

输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。

输入示例：

```text
4 5
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1
```

输出示例：

3

提示信息

https://code-thinking-1253855093.file.myqcloud.com/pics/20240516111613.png（图像链接）

根据测试案例中所展示，岛屿数量共有 3 个，所以输出 3。

数据范围：

* 1 <= N, M <= 50

## 思路

注意题目中每座岛屿只能由**水平方向和/或竖直方向上**相邻的陆地连接形成。

也就是说斜角度链接是不算了， 例如示例二，是三个岛屿，如图：

https://code-thinking-1253855093.file.myqcloud.com/pics/20220726094200.png（图像链接）


这道题题目是 DFS，BFS，并查集，基础题目。

本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。

在遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。

那么如何把节点陆地所能遍历到的陆地都标记上呢，就可以使用 DFS，BFS或者并查集。

### 深度优先搜索

以下代码使用dfs实现，如果对dfs不太了解的话，**建议按照代码随想录的讲解顺序学习**。

C++代码如下：

```cpp
// 版本一 
#include <iostream>
#include <vector>
using namespace std;

int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
    for (int i = 0; i < 4; i++) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的

            visited[nextx][nexty] = true;
            dfs(grid, visited, nextx, nexty);
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }

    vector<vector<bool>> visited(n, vector<bool>(m, false));

    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (!visited[i][j] && grid[i][j] == 1) {
                visited[i][j] = true;
                result++; // 遇到没访问过的陆地，+1
                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
            }
        }
    }

    cout << result << endl;
}
```

很多录友可能有疑惑，为什么 以上代码中的dfs函数，没有终止条件呢？ 感觉递归没有终止很危险。

其实终止条件 就写在了 调用dfs的地方，如果遇到不合法的方向，直接不会去调用dfs。

当然也可以这么写：

```cpp
// 版本二
#include <iostream>
#include <vector>
using namespace std;
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水
    visited[x][y] = true; // 标记访问过
    for (int i = 0; i < 4; i++) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
        dfs(grid, visited, nextx, nexty);
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }

    vector<vector<bool>> visited(n, vector<bool>(m, false));

    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (!visited[i][j] && grid[i][j] == 1) {
                result++; // 遇到没访问过的陆地，+1
                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
            }
        }
    }
    cout << result << endl;
}
```

这里大家应该能看出区别了，无疑就是版本一中 调用dfs 的条件判断 放在了 版本二 的 终止条件位置上。

**版本一的写法**是 ：下一个节点是否能合法已经判断完了，传进dfs函数的就是合法节点。

**版本二的写法**是：不管节点是否合法，上来就dfs，然后在终止条件的地方进行判断，不合法再return。

**理论上来讲，版本一的效率更高一些**，因为避免了 没有意义的递归调用，在调用dfs之前，就做合法性判断。 但从写法来说，可能版本二 更利于理解一些。（不过其实都差不太多）

很多同学看了同一道题目，都是dfs，写法却不一样，**有时候有终止条件，有时候连终止条件都没有，其实这就是根本原因，两种写法而已**。

## 总结

其实本题是 dfs，bfs 模板题，但正是因为是模板题，所以大家或者一些题解把重要的细节都很忽略了，我这里把大家没注意的但以后会踩的坑 都给列出来了。

本篇我只给出的dfs的写法，大家发现我写的还是比较细的，那么后面我再单独给出本题的bfs写法，虽然是模板题，但依然有很多注意的点，敬请期待！

## 其他语言版本

### Python

